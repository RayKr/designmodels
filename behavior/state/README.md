# 状态模式

## 概述
当一个对象的内在状态改变时允许改变其行为，这个对象看起来是改变了其类。

当控制一个对象状态转换的条件过于复杂时，把状态的判断逻辑转移到表示不同的一系列类当中，可以把复杂的逻辑简单化。

## 角色
* 上下文环境类（Context）： 定义了客户程序需要的接口并维护一个具体状态角色实例，并将状态相关的操作委托给状态对象来处理。
* 抽象状态（State）：定义接口，封装Context的一个特定状态相关行为。
* 具体状态（ConcreteState）：实现抽象状态接口。

## 代码
现用状态模式来实现电灯的开和关操作。

整个行为是面对电灯这个对象的，有打开和关闭开关的操作，其实两个动作可以抽象成一个按开关的操作，由于按开关时，原状态的不同就会形成不同的动作。例如原状态为关闭时，按开关为开灯；原状态为打开状态时，按开关为关灯。

根据分析，可以确定电灯抽象为上下文类（Context），其中包含电灯开关的按压方法（pressSwitch）和当前电灯开或关的状态（state）。将状态抽象封装为状态类，其中包含一个依赖电灯类的方法（pressSwitch(Light light)），将电灯的状态作为参数，就可以实现根据当前状态而进行不同的操作。

由Client中调用的代码可以看出，执行了两次相同的按下开关的操作，但是由于操作时状态的不同，执行了不同的方法。这就是状态模式的精髓。

## 总结

### 优点
* 与特定状态相关的行为（按下开关）局部化，并且将不同的状态行为分割开来（两个具体实现类LightOff和LightOn）。
* 扩展性良好。可以通过再实现一种新的状态，从而实现新的行为。（比如电灯的状态除了开和关，还增加一种渐变的状态，则可以创建一个新的状态实现类即可。）
* 具体状态类之间的逻辑互不影响，减少依赖。

### 缺点
* 可能会导致过多的具体状态类。

### 适用场景
* 当一个对象的行为取决于它的状态时，并且必须在运行时刻根据状态不同而改变行为时（如电灯是开还是关跟当前状态有关）。
* 一个操作中含有庞大的分支结构，并且这些分支决定对象的状态。




